{
    "collab_server" : "",
    "contents" : "rm(list=ls(all=TRUE))\nx<-iris;eta=0.1#the learning rate\nt1<-c(rep(1,50),rep(0,50),rep(0,50));t2<-c(rep(0,50),rep(1,50),rep(0,50));t3<-c(rep(0,50),rep(0,50),rep(1,50))#third target\n\n#generates random weights, initializes weights, random bias and activation\ngneuron<-function(n){\n  w<-runif(4, 1e-3, 1e-2)#random weights\n  #w1=w[1];w2=w[2];w3=w[3];w4=w[4]#initiating weights\n  b<-runif(1)#random bias\n  x1<-iris[,1];x2<-iris[,2]; x3<-iris[,3]; x4<-iris[,4]\n  z=x1*w[1] + x2*w[2] + x3*w[3] + x4*w[4] +b\n  h<-list(z,w,b)\n  return(h)\n}\nl.neurons<-lapply(1:3, function(x) gneuron(x));names(l.neurons)<-c(\"z1\",\"z2\",\"z3\")\n\nl.neurons$z1\n\nfor (generation in 1:1000){\n  #l.neurons<-lapply(1:3, function(x) gneuron(x));names(l.neurons)<-c(\"z1\",\"z2\",\"z3\")\n  z1e<-exp(unlist(l.neurons[[1]][1]))\n  z2e<-exp(unlist(l.neurons[[2]][[1]]))\n  z3e<-exp(unlist(l.neurons[[3]][[1]]))\n  z1e\n  exp.act.list<-list(z1e,z2e,z3e)\n  \n  y1<-unlist(z1e)/(unlist(z1e)+unlist(z2e)+unlist(z3e));\n  y2<-unlist(z2e)/(unlist(z1e)+unlist(z2e)+unlist(z3e));\n  y3<-unlist(z3e)/(unlist(z1e)+unlist(z2e)+unlist(z3e))\n  y=cbind(unlist(y1),unlist(y2),unlist(y3))\n  e1=t1-y[,1];e2=t2-y[,2];e3=t3-y[,3];e<-cbind(e1,e2,e3)\n  updated.wx<-NULL;gc<-NULL;delta.w<-NULL;n.r<-NULL;sum.w<-NULL;bias<-NULL;delta.bias<-NULL\n  for (n in 1:3){\n    delta.bias[[n]]<-append(bias,(-sum(e[,n])/150))\n    \n    for (c in 1:4){\n      for (r in 1:150){\n        gc<-rbind(gc, x[r,c] * e[r,n])\n      }\n      delta.w[c]<- -sum(gc)  \n      gc<-NULL\n    }\n    n.r[[n]]<-delta.w\n    updated.wx<-NULL\n    sw<-NULL\n  }\n  n.r\n  delta.w\n  delta.bias\n  #w_current - eta * (-sum(t - y) * x)\n  #weights_biases[1:nrow(weights_biases) - 1, neuron] - eta * (-colSums(x[, 1:ncol(x) - 1] * e[, neuron])) / nrow(t)\n  \n  for (n in 1:3){\n    l.neurons[[n]][[3]]<-cbind(l.neurons[[n]][[3]], l.neurons[[n]][[3]][generation]-eta*delta.bias[[n]])      \n    l.neurons[[n]][[2]]<-rbind(l.neurons[[n]][[2]],l.neurons[[n]][[2]][generation]- eta*n.r[[n]])\n    \n  }\n  \n}\nl.neurons$z1\n\nplot(1:1001,l.neurons[[1]][[2]][,1], ylim=c(-300,300), col=\"red\", ylab= \"weights\", xlab=\"Epochs\" )\nlines(1:1001,l.neurons[[1]][[2]][,2], col=\"green\")\nlines(1:1001,l.neurons[[1]][[2]][,3], col=\"blue\")\nlines(1:1001,l.neurons[[1]][[2]][,4], col=\"orange\")\nlines(1:1001,l.neurons[[2]][[2]][,1], col=\"green\")\nlines(1:1001,l.neurons[[2]][[2]][,2], col=\"green\")\nlines(1:1001,l.neurons[[2]][[2]][,3], col=\"green\")\nlines(1:1001,l.neurons[[2]][[2]][,4], col=\"green\")\nlines(1:1001,l.neurons[[3]][[2]][,1], col=\"green\")\nlines(1:1001,l.neurons[[3]][[2]][,2], col=\"green\")\nlines(1:1001,l.neurons[[3]][[2]][,3], col=\"green\")\nlines(1:1001,l.neurons[[3]][[2]][,4], col=\"green\")\nl.neurons[[3]][[2]]\n\n\n\n\nrm(list=ls(all=TRUE))\nx<-iris\neta=0.1#the learning rate\nt1<-c(rep(1,50),rep(0,50),rep(0,50))\nt2<-c(rep(0,50),rep(1,50),rep(0,50))\nt3<-c(rep(0,50),rep(0,50),rep(1,50))#third target\n\n#generates random weights, initializes weights, random bias and activation\ngneuron<-function(n){\n  w<-runif(4, 1e-3, 1e-2)#random weights\n  #w1=w[1];w2=w[2];w3=w[3];w4=w[4]#initiating weights\n  b<-runif(1)#random bias\n  x1<-iris[,1];x2<-iris[,2]; x3<-iris[,3]; x4<-iris[,4]\n  z=x1*w[1] + x2*w[2] + x3*w[3] + x4*w[4] +b\n  h<-list(z,w,b)\n  return(h)\n}\n\nl.neurons<-lapply(1:3, function(x) gneuron(x));names(l.neurons)<-c(\"z1\",\"z2\",\"z3\")\nl.neurons[[1]][[5]]<-l.neurons[[1]][[2]]\nl.neurons[[2]][[5]]<-l.neurons[[2]][[2]]\nl.neurons[[3]][[5]]<-l.neurons[[3]][[2]]\n\nfor (generation in 1:1000){\n  \n  for ( n in 1:3){\n    temp<-NULL\n    for (xw in 1:4){\n      temp<-cbind(temp,matrix(l.neurons[[n]][[2]][xw] %*% x[,xw], ncol =1 ))\n    }\n    l.neurons[[n]][[4]]<-temp[,1]+temp[,2]+temp[,3]+temp[,4]+l.neurons[[n]][[3]]\n  }\n  \n  z1e<-exp(unlist(l.neurons[[1]][[4]]))\n  z2e<-exp(unlist(l.neurons[[2]][[4]]))\n  z3e<-exp(unlist(l.neurons[[3]][[4]]))\n  y1<-unlist(z1e)/(unlist(z1e)+unlist(z2e)+unlist(z3e));\n  y2<-unlist(z2e)/(unlist(z1e)+unlist(z2e)+unlist(z3e));\n  y3<-unlist(z3e)/(unlist(z1e)+unlist(z2e)+unlist(z3e))\n  y=cbind(unlist(y1),unlist(y2),unlist(y3))\n  \n  e1=t1-y[,1];e2=t2-y[,2];e3=t3-y[,3];e<-cbind(e1,e2,e3)\n  updated.wx<-NULL;gc<-NULL;delta.w<-NULL;n.r<-NULL;sum.w<-NULL;bias<-NULL;delta.bias<-NULL\n  for (n in 1:3){\n    delta.bias[[n]]<-append(bias,(-sum(e[,n])/150))\n    for (c in 1:4){\n      for (r in 1:150){\n        gc<-rbind(gc, x[r,c] * e[r,n])\n      }\n      delta.w[c]<- -sum(gc)  \n      gc<-NULL\n    }\n    n.r[[n]]<-delta.w\n    updated.wx<-NULL\n    sw<-NULL\n  }\n  \n  \n  for (n in 1:3){\n    l.neurons[[n]][[3]]= l.neurons[[n]][[3]]-eta*delta.bias[[n]]\n    l.neurons[[n]][[2]]=l.neurons[[n]][[2]]- eta*n.r[[n]]\n    \n  }\n  l.neurons[[n]][[5]]<-rbind(l.neurons[[n]][[5]],l.neurons[[n]][[2]])\n}\n\nl.neurons[[n]][[5]]\nfor(i in 1:10){\n  for(n in 1:3){\n    \n    l.neurons[[n]][[5]]<-rbind(l.neurons[[n]][[5]],l.neurons[[n]][[2]]) \n  }\n}\n\n\n\n\n\nl.neurons[[1]][[5]]\n\n\nplot(1:1001,l.neurons[[1]][[2]][,1], ylim=c(-300,300), col=\"red\", ylab= \"weights\", xlab=\"Epochs\" )\nlines(1:1001,l.neurons[[1]][[2]][,2], col=\"green\")\nlines(1:1001,l.neurons[[1]][[2]][,3], col=\"blue\")\nlines(1:1001,l.neurons[[1]][[2]][,4], col=\"orange\")\nlines(1:1001,l.neurons[[2]][[2]][,1], col=\"green\")\nlines(1:1001,l.neurons[[2]][[2]][,2], col=\"green\")\nlines(1:1001,l.neurons[[2]][[2]][,3], col=\"green\")\nlines(1:1001,l.neurons[[2]][[2]][,4], col=\"green\")\nlines(1:1001,l.neurons[[3]][[2]][,1], col=\"green\")\nlines(1:1001,l.neurons[[3]][[2]][,2], col=\"green\")\nlines(1:1001,l.neurons[[3]][[2]][,3], col=\"green\")\nlines(1:1001,l.neurons[[3]][[2]][,4], col=\"green\")\nl.neurons[[3]][[2]]\n\n\n# l.neurons[[1]][[2]] %*% x[,1:4]\n# \n# \n# for ( n in 1:3){\n#   temp<-NULL\n#   for (xw in 1:4){\n#   temp<-cbind(temp,matrix(l.neurons[[n]][[2]][xw] %*% x[,xw], ncol =1 ))\n#   }\n# l.neurons[[n]][[4]]<-temp[,1]+temp[,2]+temp[,3]+temp[,4]+l.neurons[[n]][[3]]\n# }\n\nfor (generation in \n     \n     ",
    "created" : 1498676293295.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2421457506",
    "id" : "118AA28E",
    "lastKnownWriteTime" : 1498676345,
    "last_content_update" : 1498676345659,
    "path" : "~/machine_learning/multi_layer_neuron/multineuron_scrap.R",
    "project_path" : "multineuron_scrap.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}