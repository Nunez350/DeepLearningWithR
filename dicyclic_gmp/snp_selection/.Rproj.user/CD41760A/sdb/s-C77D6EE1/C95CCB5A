{
    "collab_server" : "",
    "contents" : "rm(list=ls(all=TRUE))\ndev.off()\nlibrary(glmnet)\nsource('~/machine_learning/dicyclic_gmp/snp_selection/di_ci_gmp_data.R')\nt\nt<-m.cdgmp\npar(mfrow=c(2,5))\n\n\n#fitted models (gmlnet output)\nfor (i in 1:50){\n  \n  x<-t(snp.by.gene.uniq[[i]])\n  split<-sample(nrow(x), floor(0.7*nrow(x)))\n  train.d<-as.matrix(cbind(x,t)[split,])\n  test.d<-as.matrix(cbind(x,t)[-split,])\n  train.m<-train.d[,-ncol(train.d)]\n  target<-train.d[,ncol(train.d)]\n  target<-abs(target)\n  fit <- glmnet(train.m, target, family = \"poisson\")\n  cv<-cv.glmnet(train.m,target,nfolds = 10)#cross_validate to get the best lambda\n  pred<-predict(fit, train.m, type=\"response\",s=cv$lambda.min)#p\n  plot(fit, label = TRUE) \n  fit\n  title(paste(\"Gene\",i,\"SNPS\",ncol(x)),line = +2)\n  #i<-i+1  \n  \n  \n}\n#dev.off()\n# Each curve corresponds to a variable. It shows the path of its coefficient against the `1-norm of the whole\n# coefficient vector at as lambda varies. The axis above indicates the number of nonzero coefficients at the current lambda\n# which is the effective degrees of freedom (df ) for the lasso.\n# \n# \ncv_plots<-function(x,s){\n  lapply(snp.by.gene.uniq, function(x){\n    x<-t(x)\n    i=parent.frame()$i[]\n    split<-sample(nrow(x), floor(0.7*nrow(x)))\n    train.d<-as.matrix(cbind(x,t)[split,])\n    test.d<-as.matrix(cbind(x,t)[-split,])\n    train.m<-train.d[,-ncol(train.d)]\n    target<-train.d[,ncol(train.d)]\n    target<-abs(target)\n    fit <- glmnet(train.m, target, family = \"poisson\")\n    cv<-cv.glmnet(train.m,target,nfolds = 10)#cross_validate to get the best lambda\n    pred<-predict(fit, train.m, type=\"response\",s=cv$lambda.min)#p\n    plot(cv, label = TRUE) \n    title(paste(\"Gene\",i,\"SNPS\",ncol(x)),line = +2)\n    i<-i+1\n  })\n  \n}\ncv_plots(snp.by.gene.uniq)\n# the cross-validation curve (red dotted line), and upper and lower standard deviation curves along\n# the  sequence (error bars). Two selected lambdaâ€™s are indicated by the vertical dotted lines \n\nfit_deviance<-function(x,s){\n  lapply(snp.by.gene.uniq, function(x){\n    x<-t(x)\n    i=parent.frame()$i[]\n    split<-sample(nrow(x), floor(0.7*nrow(x)))\n    train.d<-as.matrix(cbind(x,t)[split,])\n    test.d<-as.matrix(cbind(x,t)[-split,])\n    train.m<-train.d[,-ncol(train.d)]\n    target<-train.d[,ncol(train.d)]\n    target<-abs(target)\n    fit <- glmnet(train.m, target, family = \"poisson\")\n    cv<-cv.glmnet(train.m,target,nfolds = 10)#cross_validate to get the best lambda\n    pred<-predict(fit, train.m, type=\"response\",s=cv$lambda.min)#p\n    plot(fit, xvar = \"dev\", label = TRUE)\n    #plot(fit, label = TRUE) \n    title(paste(\"Gene\",i,\"SNPS\",ncol(x)),line = +2)\n    i<-i+1\n  })\n}\nfit_deviance(snp.by.gene.uniq)\n# fit_deviance(snp.by.gene.uniq)\n# This is percent deviance.  \ni<-5\nlm_corr_plot<-function(i){\n  x<-t(snp.by.gene.uniq[[i]])\n  split<-sample(nrow(x), floor(0.7*nrow(x)))\n  train.d<-as.matrix(cbind(x,t)[split,])\n  test.d<-as.matrix(cbind(x,t)[-split,])\n  train.m<-train.d[,-ncol(train.d)]\n  target<-train.d[,ncol(train.d)]\n  target<-abs(target)\n  fit <- glmnet(train.m, target, family = \"poisson\")\n  cv<-cv.glmnet(train.m,target,nfolds = 10)#cross_validate to get the best lambda\n  pred<-predict(fit, train.m, type=\"response\",s=cv$lambda.min)\n  plot(pred[,1], target)\n  title(paste(\"Gene\",i,\"SNPS\",ncol(x)),line = +2)\n  abline(lm( target ~ pred[,1]), col=2)\n\n}\nfor (j in 1:50){\n  lm_corr_plot(j)\n  #g(j)\n # abline(lm(target ~ pred[,1]), col=2)#####getting error since \n}#\nt<-m.cdgmp+10\nt\nr.corr<-vector()\npvalues<-vector()\nr.co<-vector()\nfor (c in 1:50){  \n  x<-t(snp.by.gene.uniq[[c]])\n  split<-sample(nrow(x), floor(0.7*nrow(x)))\n  train.d<-as.matrix(cbind(x,t)[split,])\n  test.d<-as.matrix(cbind(x,t)[-split,])\n  train.m<-train.d[,-ncol(train.d)]\n  target<-train.d[,ncol(train.d)]\n  fit <- glmnet(train.m, target, family = \"poisson\")\n  cv<-cv.glmnet(train.m,target,nfolds = 10)#cross_validate to get the best lambda\n  pred<-predict(fit, train.m, type=\"response\",s=cv$lambda.min)\n  r<-cor.test(pred[,1], target)\n  r.corr[[c]]<-r$estimate\n  pvalues[[c]]<-r$p.value\n  r.co[[c]]<-summary(lm(target ~ pred[,1]))$r.squared\n}\ncor.test(pred[,1], target)$p.value\npar(mfrow=c(1,3)) \nhist(r.corr, main= \"Association-Correlation\", col = \"red\")\nhist(pvalues, main = \"P-values\", col=\"blue\")\nhist(r.co, main= \"R-squared\", col=\"green\")\n#dev.off()\n\n\nlibrary(plotmo) # for plotres\nfor (i in 1:5){\n  x<-t(snp.by.gene.uniq[[i]])\n  split<-sample(nrow(x), floor(0.7*nrow(x)))\n  train.d<-as.matrix(cbind(x,t)[split,])\n  test.d<-as.matrix(cbind(x,t)[-split,])\n  train.m<-train.d[,-ncol(train.d)]\n  target<-train.d[,ncol(train.d)]\n  target<-abs(target)\n  fit <- glmnet(train.m, target, family = \"poisson\")\n  cv<-cv.glmnet(train.m,target,nfolds = 10)#cross_validate to get the best lambda\n  pred<-predict(fit, train.m, type=\"response\",s=cv$lambda.min)#p\n  plotres(fit, labels.id = TRUE,main=paste(\"Gene\",i,\"SNPS\",ncol(x)))\n}\npar(mfrow=c(2,5))\nplotres(fit)\ncor.test(pred[,1], target)\nsummary(lm( target ~ pred[,1]))$r.squared\n\nfit_lambda<-function(x,s){\n  lapply(snp.by.gene.uniq, function(x){\n    x<-t(x)\n    i=parent.frame()$i[]\n    split<-sample(nrow(x), floor(0.7*nrow(x)))\n    train.d<-as.matrix(cbind(x,t)[split,])\n    test.d<-as.matrix(cbind(x,t)[-split,])\n    train.m<-train.d[,-ncol(train.d)]\n    target<-train.d[,ncol(train.d)]\n    target<-abs(target)\n    fit <- glmnet(train.m, target, family = \"poisson\")\n    cv<-cv.glmnet(train.m,target,nfolds = 10)#cross_validate to get the best lambda\n    pred<-predict(fit, train.m, type=\"response\",s=cv$lambda.min)#p\n    plot(fit, xvar = \"lambda\", label = TRUE)\n    #plot(fit, label = TRUE) \n    title(paste(\"Gene\",i,\"SNPS\",ncol(x)),line = +2)\n    i<-i+1\n  })\n}\nfit_lambda(snp.by.gene.uniq)\n\naccuracy<-function(x,s){\n  lapply(snp.by.gene.uniq, function(x){\n    x<-t(x)\n    i=parent.frame()$i[]\n    split<-sample(nrow(x), floor(0.7*nrow(x)))\n    train.d<-as.matrix(cbind(x,t)[split,])\n    test.d<-as.matrix(cbind(x,t)[-split,])\n    train.m<-train.d[,-ncol(train.d)]\n    target<-train.d[,ncol(train.d)]\n    target<-abs(target)\n    fit <- glmnet(train.m, target, family = \"poisson\")\n    cv<-cv.glmnet(train.m,target,nfolds = 10)#cross_validate to get the best lambda\n    pred<-predict(fit, train.m, type=\"response\",s=cv$lambda.min)#p\n    acc<-sum(abs(target-pred))/100\n    \n  })\n}\naccuracy(snp.by.gene.uniq)\nfit_deviance(snp.by.gene.uniq)\nlapply(snp.by.gene.uniq, function(x){\n  glmnet(t(x), t, family = \"mgaussian\",type.multinomial = \"grouped\")  \n})\nglmnet(as.matrix(snp.by.gene.uniq), t, family = \"mgaussian\",type.multinomial = \"grouped\")\ncvfit=cv.glmnet(x, y, family=\"multinomial\", type.multinomial = \"grouped\", parallel = TRUE)\nunlist(t(snp.by.gene.uniq))\nsnp.by.gene.uniq[[1]]\n\nas.matrix(snp.by.gene.uniq)\n#  a single curve is plotted per variable, a coefficient plot is created for each response \n#for (i in 1:50){\n  \n  x<-t(snp.by.gene.uniq[[i]])\n  split<-sample(nrow(x), floor(0.7*nrow(x)))\n  train.d<-as.matrix(cbind(x,t)[split,])\n  test.d<-as.matrix(cbind(x,t)[-split,])\n  train.m<-train.d[,-ncol(train.d)]\n  target<-train.d[,ncol(train.d)]\n  target<-abs(target)\n  fit <- glmnet(train.m, target, family = \"poisson\")\n  cv<-cv.glmnet(train.m,target,nfolds = 10)#cross_validate to get the best lambda\n  pred<-predict(fit, train.m, type=\"response\",s=cv$lambda.min)#p\n  plot(fit, label = TRUE) \n  title(paste(\"Gene\",i,\"SNPS\",ncol(x)),line = +2)\n  #i<-i+1  \n  \n  \n}\n\n# \n# for (c in 1:50){  \n#   x<-t(snp.by.gene.uniq[[c]])\n#   split<-sample(nrow(x), floor(0.7*nrow(x)))\n#   train.d<-as.matrix(cbind(x,t)[split,])\n#   test.d<-as.matrix(cbind(x,t)[-split,])\n#   train.m<-train.d[,-ncol(train.d)]\n#   target<-train.d[,ncol(train.d)]\n#   target<-abs(target)\n#   fit <- glmnet(train.m, target, family = \"poisson\")\n#   cv<-cv.glmnet(train.m,target,nfolds = 10)#cross_validate to get the best lambda\n#   pred<-predict(fit, train.m, type=\"response\",s=cv$lambda.min)\n#   r<-cor.test(pred[,1], target)\n#   r.corr[[c]]<-r$estimate\n#   pvalues[[c]]<-r$p.value\n#   r.co<-summary(lm( target ~ pred[,1]))$r.squared\n# }",
    "created" : 1501856253914.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "35|24|53|0|\n58|28|76|0|\n81|26|96|0|\n131|15|143|0|\n149|26|167|0|\n170|24|186|0|\n199|17|216|0|\n",
    "hash" : "719841",
    "id" : "C95CCB5A",
    "lastKnownWriteTime" : 1501856967,
    "last_content_update" : 1505099254754,
    "path" : "~/rest/lasso_aug4.R",
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled4"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}