{
    "collab_server" : "",
    "contents" : "rm(list=ls(all=TRUE))\nsetwd(\"~/msk-snp-cdgmp/cdg-data/\")\nsnp.data<-read.csv(\"cdgSNPmatrix-Jinyuan_roy.csv\", sep =\",\", header = T, row.names = 1)\nsnp.by.gene <- split(snp.data, strtrim(rownames(snp.data), 8))\nsnp.by.gene.uniq <- lapply(snp.by.gene, function(x) unique(x))\ntest1 <- snp.by.gene.uniq[[1]]\ntest1<-t(test1)\n\ncdgmp.data<-read.csv(\"cdgTable.csv2\", sep =\",\", header =T)\nm.cdgmp<-tapply(cdgmp.data$logcdg,cdgmp.data$strains,mean )\nnames(m.cdgmp)[16]<-gsub(\"pa_.+_\", \"\", names(m.cdgmp)[16])\nm.cdgmp<-m.cdgmp[rownames(test1)]\n\n\neta=0.1#the learning rate\nsnp.by.gene.uniq\ndist(snp.by.gene.uniq)\n\n# #reducing the data dimensionality, grouping by hclust\ndist.training.snps<-dist(training.snps, method = 'manhattan')\n# cluster.dist.training.snps<-hclust(dist.training.snps)\n# plot(cluster.dist.training.snps)\n# ct<-cutree(cluster.dist.training.snps, k=4)\n# length(which(ct ==1))\n# length(snps[which(ct == 1)])\n\ntest1 <- snp.by.gene.uniq[[1]]\nsnps<-t(test1)\n\n\n\n\n\nneuralFunction<-function(x){\n  performance<-list()\n  hit.acc<-list()\n  test.hit.acc<-list()\n  for (trials in 1:10) {\n    \n    #randomly splitting the SNPS strains into training and predictive testing sets\n    split.indeces<-split(1:30, sample(rep(1:2, c(20,10))))\n    training.snps<-snps[split.indeces$`1`,] # N =20\n    test.snps<-snps[split.indeces$`2`,]\n    training.cdgmp<-m.cdgmp[rownames(training.snps)]\n    testing.cdgmp<-m.cdgmp[rownames(test.snps)]\n    \n    #declaring targets for di-gmp levels high, medium low\n    t1 <- as.matrix(ifelse(training.cdgmp > -.5, 1,0 )) # high\n    t2 <- as.matrix(ifelse(training.cdgmp < -.5 & training.cdgmp > -1.5, 1,0)) # medium \n    t3 <- as.matrix(ifelse(training.cdgmp  < -1.5 , 1,0 )) #low\n    targets<-cbind(t1,t2,t3)\n    \n    weight_bias<-NULL\n    for(i in 1:3){\n      w <- runif(ncol(training.snps), 1e-3, 1e-2)\n      b <- runif(1)\n      weight_bias<-cbind(weight_bias,as.matrix(c(w,b)))\n    }\n    \n    \n    training.snps2<-cbind(training.snps,rep(1,20))\n    \n    wdf=data.frame(w1=numeric(), w2=numeric(),w3=numeric(),w4=numeric(), b=numeric()) \n    nwdf<-list(wdf,wdf,wdf)\n    accuracy<-list()\n    training.snps2  \n    weight_bias\n    for (generation in 1:1000){\n      linear.combination<-training.snps2 %*% weight_bias\n      \n      y <- exp(linear.combination) / rowSums(exp(linear.combination))\n      e<-targets-y\n      for (neuron in 1:3){\n        weight_bias[5,neuron]=weight_bias[5,neuron]-eta*(-sum(e[,neuron])/20)\n        for (weight in 1:ncol(training.snps)){\n          gc<-training.snps2[,weight]*e[,neuron]\n          weight_bias[weight,neuron]=weight_bias[weight,neuron] - eta* (-sum(gc)/20)\n        }\n        nwdf[[neuron]]<-rbind(nwdf[[neuron]],t(weight_bias)[neuron,])    \n      }  \n      accuracy[[generation]]<-length(which(max.col(y)==max.col(targets)))/20\n    }\n    \n    \n    \n    final.wts <- matrix(c(nwdf[[1]][1000,], nwdf[[2]][1000,], nwdf[[3]][1000,]), nrow=7, byrow=F)\n    \n    final.wts2 <- matrix(unlist(final.wts), nrow=7, byrow = F)\n    L<-training.snps2 %*% final.wts2\n    y <- exp(L) / rowSums(exp(L))\n    hits<-length(which(round(y[,1])==targets[,1] & round(y[,2])==targets[,2] & round(y[,3])==targets[,3]))\n    hit.acc<-rbind(hit.acc, hits/20)\n    \n    \n    \n    test1 <- as.matrix(ifelse(testing.cdgmp > -.5, 1,0 )) # high\n    test2 <- as.matrix(ifelse(testing.cdgmp < -.5 & testing.cdgmp > -1.5, 1,0)) # medium \n    test3 <- as.matrix(ifelse(testing.cdgmp  < -1.5 , 1,0 )) #low\n    test.targets<-cbind(test1,test2,test3)\n    \n    test.snps<-cbind(test.snps,rep(1,10))\n    \n    test.line<-test.snps %*% final.wts2\n    test.y <- exp(test.line) / rowSums(exp(test.line))\n    test.hits<-length(which(round(test.y[,1])==test.snps[,1] & round(test.y[,2])==test.snps[,2] & round(test.y[,3])==test.snps[,3]))\n    \n    test.hit.acc<-rbind(test.hit.acc,test.hits/10, deparse.level = 1)\n  }\n  performance<-list(hit.acc, range(hit.acc), test.hit.acc, range(test.hit.acc))\n  names(performance)<-c(\"self-prediction\",\"range_self_predict\", \"external.prediction\", \"range_external_prediction\")\n  return(performance)\n}\n\n\nout<-lapply(snp.by.gene.uniq, function(x)\n  neuralFunction(snps)\n)\n\nout.df <- lapply(out, function(x) data.frame(self=unlist(x$`self-prediction`[,1]), target=unlist(x$`external.prediction`[,1])))\n\nfor(i in 1:length(out.df)) {\n  n <- names(out.df[i]);\n  boxplot(out.df[[i]], ylim=c(0,1), ylab=\"accuracy\", las=1, main=n);\n  stripchart(out.df[[i]], vertical = T, method = 'jitter', add = TRUE, pch=16, col=1:2, ylim=c(0,1));\n}\n\nlapply(out.df,function(dx){\n  n <- names(dx);\n  #boxplot(dx, ylim=c(0,1), ylab=\"accuracy\", las=1, main=n);\n  #stripchart(dx[[1]], vertical = T, method = 'jitter', add = TRUE, pch=16, col=1:2, ylim=c(0,1))\n})\n\nlibrary(ape)\ntr=read.tree(\"cdg-tree-v1-mid.dnd\")\ntxt.names=read.table(\"cdg.strains.txt3\", sep=\"\\t\", header = F, row.names = 1)\ntr$tip.label <- as.character(txt.names[tr$tip.label,]) #\ntr$tip.label<-as.character(txt.names$V2[match(tr$tip.label, txt.names$V1)])\nplot(tr, font =1)\nadd.scale.bar()\ncutree(tr, k =4)\ntr\n#plot(0:0, xlim = c(1,1000), ylim=c(-4,4) ,ylab= \"weights\", xlab=\"Epochs\", main = \"Weight Updates\")\n#lapply(nwdf[[1]][1:4],function(x){ lines(1:1000, x, col=\"2\" ) })\n# lapply(nwdf[[2]][1:4],function(x){ lines(1:1000, x, col=\"3\" ) })\n# lapply(nwdf[[3]][1:4],function(x){ lines(1:1000, x, col=\"4\") })\n# legend(\"topleft\", legend = c(\"neuron 1\",\"neuron 2\", \"neuron 3\"), col=c(\"2\",\"3\",\"4\"), pch=10, horiz = T, cex = .9) \n# \n# plot(1:1000, unlist(accuracy), xlab = \"Epochs\", ylab = \"Accuracy\", main = \"Accuracy Plot\")\n# \n# \n# \n#pdf(\"Self prediction vs External Prediction\")\n#\n#\n#\n#\n#\n#\n#\n#\n#\nlapply(out,function(dx){\n  plot(dx[[1]], type=\"o\", col=\"blue\", ylim=c(0,1), axes=FALSE, ann=FALSE)\n  lines(dx[[3]], type=\"o\", pch=22, lty=2, col=\"red\")\n  title(main=\"predictions\", col.main=\"red\", font.main=4)\n  title(xlab=\"percent accuracy\", col.lab=rgb(0,0.5,0))\n  title(ylab=\"Iterations\", col.lab=rgb(0,0.5,0))\n  legend(1, g_range[2], c(\"self-prediction\",\"external.prediction\"), cex=0.8, \n         col=c(\"blue\",\"red\"), pch=21:22, lty=1:2);\n  \n})\n\nlapply(out,function(dx){\n  g_range<-range(0, dx[[1]],dx[[3]])\n  plot(dx[[1]], type=\"o\", col=\"blue\", ylim=g_range, axes=FALSE, ann=FALSE)\n  axis(2, las=1, at=4*0:g_range[2])\n  lines(dx[[3]], type=\"o\", pch=22, lty=2, col=\"red\")\n  title(main=\"predictions\", col.main=\"red\", font.main=4)\n  title(xlab=\"percent accuracy\", col.lab=rgb(0,0.5,0))\n  title(ylab=\"Iterations\", col.lab=rgb(0,0.5,0))\n  legend(1, g_range[2], c(\"self-prediction\",\"external.prediction\"), cex=0.8, \n         col=c(\"blue\",\"red\"), pch=21:22, lty=1:2);\n  \n})\n#dev.off()\n\n\nlibrary(ape)\ntr=read.tree(\"cdg-tree-v1.dnd\")\ntxt.names=read.table(\"cdg.strains.txt3\")\ntr$tip.label<-as.character(txt.names$V2[match(tips, txt.names$V1)])\nplot(tr)\n# \n# #return(list(snps, targets))\n# gene1<-neuralFunction(snps)\n# gene1\n# plot(gene)\n# gene1$self-prediction\n# plot(gene1$`self-prediction`, gene1$external.prediction, type= \"l\")\n# lapply(nwdf[[1]][1:4],function(x){ lines(1:1000, x, col=\"2\" ) })\n# \n# \n# \n# g_range<-range(0, gene1$`self-prediction`,gene1$external.prediction)\n# \n# plot(gene1$`self-prediction`, type=\"o\", col=\"blue\", ylim=g_range, \n#      axes=FALSE, ann=FALSE)\n# axis(2, las=1, at=4*0:g_range[2])\n# box()\n# lines(gene1$external.prediction, type=\"o\", pch=22, lty=2, col=\"red\")\n# title(main=\"predictions\", col.main=\"red\", font.main=4)\n# title(xlab=\"percent accuracy\", col.lab=rgb(0,0.5,0))\n# title(ylab=\"Iterations\", col.lab=rgb(0,0.5,0))\n# \n# \n# legend(1, g_range[2], c(\"self-prediction\",\"external.prediction\"), cex=0.8, \n#        col=c(\"blue\",\"red\"), pch=21:22, lty=1:2);\n# \n# \n# \n# \n# out\n# out$peg.1075\n# length(out)\n# lappfor (i in 1:50 ){\n#   print(names(out[i]))\n#   \n# }\nlapply(out, function(dx){\n  names(dx)\n})\n# \n# names(out)\n# lapply(out,function(dx){\n#   g_range<-range(0, dx[[1]],dx[[3]])\n#   plot(dx[[1]], type=\"o\", col=\"blue\", ylim=g_range, \n#        axes=FALSE, ann=FALSE)\n#   axis(2, las=1, at=4*0:g_range[2])\n#   lines(dx[[3]], type=\"o\", pch=22, lty=2, col=\"red\")\n#   title(main=\"predictions\", col.main=\"red\", font.main=4)\n#   title(xlab=\"percent accuracy\", col.lab=rgb(0,0.5,0))\n#   title(ylab=\"Iterations\", col.lab=rgb(0,0.5,0))\n#   legend(1, g_range[2], c(\"self-prediction\",\"external.prediction\"), cex=0.8, \n#          col=c(\"blue\",\"red\"), pch=21:22, lty=1:2);\n# \n# })\n# \n# \n# \n# \n# \n# g_range<-range(0, gene1$`self-prediction`,gene1$external.prediction)\n# \n# plot(gene1$`self-prediction`, type=\"o\", col=\"blue\", ylim=g_range, \n#      axes=FALSE, ann=FALSE)\n# axis(2, las=1, at=4*0:g_range[2])\n# box()\n# lines(gene1$external.prediction, type=\"o\", pch=22, lty=2, col=\"red\")\n# title(main=\"predictions\", col.main=\"red\", font.main=4)\n# title(xlab=\"percent accuracy\", col.lab=rgb(0,0.5,0))\n# title(ylab=\"Iterations\", col.lab=rgb(0,0.5,0))\n# \n# \n# legend(1, g_range[2], c(\"self-prediction\",\"external.prediction\"), cex=0.8, \n#        col=c(\"blue\",\"red\"), pch=21:22, lty=1:2);\n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# test3 <- as.matrix(ifelse(testing.cdgmp  < -1.5 , 1,0 )) \n# check<-matrix()\n# check<-list()\n# for ( j in 1:10){\n# check<-rbind(check,snps[j,1], deparse.level = 1)\n# }\n# test.hit.acc<-rbind(test.hit.acc,test.hits/10, deparse.level = 1)\n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# linear.combination.predict<-training.snps2 %*% weight_bias\n# y <- exp(linear.combination.predict) / rowSums(exp(linear.combination.predict))\n# \n# round(y)\n# \n# which(round(y[,1])==targets[,1] & round(y[,2])==targets[,2] & round(y[,3])==targets[,3])\n# \n# est.tawhich(round(y[,1])==test.targets[,1] & round(y[,2])==test.targets[,2] & round(y[,3])==test.targets[,3] )\n#plot(0:0, xlim = c(1,1000), ylim=c(-4,4) ,ylab= \"weights\", xlab=\"Epochs\", main = \"Weight Updates\")\n#lapply(nwdf[[1]][1:4],function(x){ lines(1:1000, x, col=\"2\" ) })\n# lapply(nwdf[[2]][1:4],function(x){ lines(1:1000, x, col=\"3\" ) })\n# lapply(nwdf[[3]][1:4],function(x){ lines(1:1000, x, col=\"4\") })\n# legend(\"topleft\", legend = c(\"neuron 1\",\"neuron 2\", \"neuron 3\"), col=c(\"2\",\"3\",\"4\"), pch=10, horiz = T, cex = .9) \n# \n# plot(1:1000, unlist(accuracy), xlab = \"Epochs\", ylab = \"Accuracy\", main = \"Accuracy Plot\")\n# \n# test1 <- as.matrix(ifelse(testing.cdgmp > -.5, 1,0 )) # high\n# test2 <- as.matrix(ifelse(testing.cdgmp < -.5 & testing.cdgmp > -1.5, 1,0)) # medium \n# test3 <- as.matrix(ifelse(testing.cdgmp  < -1.5 , 1,0 )) #low\n# test.targets<-cbind(test1,test2,test3)\n# \n# test.snps<-cbind(test.snps,rep(1,10))\n# \n# linear.combination.predict<-test.snps %*% weight_biaslinear.combination.predict<-test.snps %*% weight_bias\n# y <- exp(linear.combination.predict) / rowSums(exp(linear.combination.predict))\n# targets\n# \n# \n# \n# \n# #length(which(max.col(y)==max.col(test.targets)))/10\n# which(round(y)==(test.targets))\n# length(which(round(y)==(test.targets)))/length(test.targets)\n# \n# test.targets\n# round(y)\n# max.col(y)\n# max.col(test.targets)\n# # \n# # t.snp.data<-t(snp.data)\n# # snp.dist<-dist(t.snp.data, method= \"manhattan\")\n# # \n# # \n# # \n# # snp.by.gene <- split(snp.data, strtrim(rownames(snp.data), 8))\n# # \n# # test <- snp.by.gene.uniq[[1]]\n# # test\n# \n# \n# final.wts <- matrix(c(nwdf[[1]][1000,], nwdf[[2]][1000,], nwdf[[3]][1000,])), nrow=7, byrow=F)\n# \n# final.wts2 <- matrix(unlist(final.wts), nrow=7, byrow = F)\n# L<-training.snps2 %*% final.wts2\n# y <- exp(L) / rowSums(exp(L))\n# which(round(y[,1])==targets[,1] & round(y[,2])==targets[,2] & round(y[,3])==targets[,3])\n",
    "created" : 1499228418369.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "851219099",
    "id" : "585746F9",
    "lastKnownWriteTime" : 111550524582252,
    "last_content_update" : 1499983389377,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}